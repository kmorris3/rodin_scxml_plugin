% !TEX root = ../main.tex

\section{Related Work}
\label{sec:relatedWork}

Many incompatible definitions of refinement have been posed by
others~\cite{Syriani_2019,Maraninchi91theargos} and that can lead to confusion.
Though these separate refinements have different goals, all of which may be
attractive to systems designers in different ways,
% preservation of safety proofs is the goal here. 
%While these other forms of refinement cannot be said to conflict with the one presented here, 
they will not always preserve safety properties.  
From the \EventB vernacular it might be better to relabel these other approaches
not as methods of model ``refinement'', but rather methods of model
``elaboration''.  
Preservation of safety properties across refinement requires only a few
restrictions to the original~\cite{Harel} \SCs (e.g., transitions cannot cross
containment boundaries arbitrarily), but still allows for both parallel and
hierarchical composition. 
With these restrictions composition becomes a refinement, but not all
refinements are compositions.  
Such a unification of composition and refinement can lead, not only to code
reuse, but reuse of proofs.

If an \EventB\ model |B| can be shown (via the construction rules of the \EventB
language as well as the proof obligations) to refine another \EventB
model |A|, then we know that every behavior of |B| is also a behavior
of |A|. This definition yields a useful principle of preservation of
safety -- if we can show that a bad thing never happens in |A|, then
we can add detail via refinements in |B|, knowing that the bad thing
will continue to never happen in |B|. That is, \EventB refinements
preserve safety properties in the sense adopted by Lamport
~\cite{lamport1977proving}. This makes refinement a useful technique
in developing safety-critical systems: one can analyze a simpler
abstract model for critical safety properties and then add detail to
the model via refinements, secure in the knowledge that the safety
properties will be preserved. While \EventB refinements have also been
shown to preserve some liveness properties under certain
conditions~\cite{hoang2016ltl}, there are not yet efficient supporting
tools for the technique. Instead, we can express the property in \LTL
and use the \PROB\footnote{ProB is an animator, constraint solver and
  model checker for the B-Method. \url{https://www3.hhu.de/stups/prob}}
model checker to verify it, as we have shown in previous
work~\cite{detect2020}.  In this paper, we outline a proof of liveness
properties that relies on reasoning about deadlock-freeness and event
convergence.

% \hl{%
  A method that is closely related to \mbox{\EventB} and also supports
  reasoning about safety and liveness properties is
  TLA+~\mbox{\cite{DBLP:books/aw/Lamport2002}}. TLA+ is supported by
  the TLA+ Toolbox~\mbox{\cite{DBLP:journals/corr/abs-1912-10633}}.
  On the one hand, temporal properties (both safety and liveness) are
  \emph{explicitly} stated as properties of the TLA+ models and
  reasoning about them often requires applying proof rules related to
  properties of traces. On the other hand, \mbox{\EventB} defines
  proof obligations based on the underlying trace
  semantics~\mbox{\cite{abrial10:_model_event_b,hoang2016ltl,hudon16:_unit_b_method}},
  hence reasoning about \emph{implicit} temporal properties in
  \mbox{\EventB} simply involves discharging the relevant proof
  obligations. Furthermore, at the time of writing, the TLA+ Proof
  System (part of the TLA+ Toolbox) does not fully support the
  reasoning with many temporal operators.%
% }%
\footnote{\url{http://tla.msr-inria.inria.fr/tlaps/content/Documentation/Unsupported_features.html}
  (accessed June 2021)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% Previous work has developed a number of different semantics all with different purposes and outcomes~\cite{Syriani_2019,Harel,Maraninchi91theargos}.  
% Because this work is focused on a mapping to \EventB, safety property preserving refinement is key.  
% \EventB provides not only a definition of refinement but a rubric for finding valid refinements and this is carried over into the \SCs work presented here. 
% In our version of \SC semantics, refinement means a subsetting of traces from an abstraction. 
% This has the beneficial effect of preserving safety properties from abstraction to refinement and permits proofs to be
% discharged at the highest tractable level of abstraction.
% It is at the highest level of abstraction that proofs are presumably the easiest to discharge.

% Many incompatible definitions of refinement have been posed by others~\cite{Syriani_2019,Maraninchi91theargos} and that can lead to confusion.  
% Though these separate refinements have different goals, all of which may be attractive to systems designers in different ways, preservation of safety proofs is the goal here. 
% While these other forms of refinement cannot be said to conflict with the one presented here, they will not always preserve safety properties.  
% From the \EventB vernacular it might be better to relabel these other approaches not as methods of model ``refinement'', but rather methods
% of model ``elaboration''.  


% Preservation of safety across refinement requires only a few restrictions to the original~\cite{Harel} \SCs (e.g., transitions cannot
% cross containment boundaries arbitrarily), but still allows for both parallel and hierarchical composition. 
% With these restrictions composition becomes a refinement, but not all refinements are compositions.  
% Such a unification of composition and refinement can lead, not only to code reuse, but reuse of proofs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




% Although the autonomous drone example in this paper is based on the
% example described in~\cite{Syriani_2019}, the definition of refinement
% used in that work is quite different from our own. This forces some
% differences in our refinement rules and consequently the way the
% example is developed.  In~\cite{Syriani_2019} ``refinement'' is a
% transformation of the model which preserves reachability of a state
% with respect to sequences of inputs. However, this also allows the
% possibility of introducing new behaviors in the concrete model that
% the abstraction does not exhibit (more details are in
% Section~\ref{sec:descr-sample-appl}). While this notion of refinement
% seems useful in certain contexts, unlike refinement in \EventB it does
% not guarantee preservation of safety properties. Therefore it should
% be considered less suited to development of safety-critical systems.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End: