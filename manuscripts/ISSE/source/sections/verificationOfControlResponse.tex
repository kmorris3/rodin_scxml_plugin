% !TEX root = ../main.tex
\section{Verification of Control Responses}
\label{sec:verificationResponses}

A model that has been proven to satisfy some invariant (e.g. safety) properties, 
may still not behave in a useful way.
Therefore, as well as verifying invariant properties, we would like to verify 
the system's responsiveness. That is, we want to ensure that the controller 
responds to external triggers and makes appropriate modifications to the system variables. 
These kind of live responses are difficult to prove via invariant
preservation since they are temporal properties.  In this section, we
present our approach to verify the responsive properties of the system.


% Different set of events
In our \EventB model, the events can be separated into the following
categories.
\begin{itemize}
\item \emph{External events}: These events raise external triggers
  including |futureRaiseExternalTrigger|, |ExternalTriggerEvent_toTakeoff|,
  |ExternalTriggerEvent_decreaseCharge|, etc.
  
\item \emph{System events}: Events other than external events are
  called system events. They are the events by which the system responds to
  the external triggers (creating different runs).  These events can be
  seen in Figure~\ref{fig:basis} and are categorised as follow.
  \begin{itemize}
  \item \emph{Future system events}: These events might raise internal
    triggers, i.e., |futureTriggeredTransitionSet|, and
    |futureUntriggeredTransitionSet|.  The purpose of these events is
    to enable future introduction of more system details via refinement.
    
  \item \emph{Dequeue external trigger events} (i.e.,
    |dequeueExternalTriggered|): These events dequeue the head of the
    external triggers queue (if any) and will start a run.

  \item \emph{Internal system events}: These events belong to the
    internal behavior of the system to accommodate the runs for external
    triggers.  These events can be seen in different groups as in
    Figure~\ref{fig:basis}.
    \begin{itemize}
    \item \emph{Dequeue internal trigger events} (i.e.,
      |dequeueInternalTriggered|): These events dequeue the head of the
      internal triggers queue (if any) and will start a run.
    
    \item \emph{Triggered events}: The events corresponding to the
      dequeued of (external or internal) triggers.

    \item \emph{Discard trigger events} (i.e.,
      |noTriggeredTransitionsEnabled|):  This event will move the system
      from the |FIRIGIN TRIGGERED| state to the |FIRING UNTRIGGERED| state 
      in the case where no triggered events are enabled.
    
    \item \emph{Untriggered events}:  These are all the untriggered 
    events in the systems.

    \item \emph{Completion events} (i.e.,
      |noUntriggeredTransitionsEnabled|): This event will move the
      system from |FIRING UNTRIGGERED| state to the |READY TO DE-QUEUE|
      state in the case where no untriggered events are
      enabled.
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{theorem}[Internal System Events are Relative Deadlock-Free]
  \label{thm:Internal-DLF}
  Under the condition that %
  |iQ /= {} !or uc = FALSE !or dt /= {}|, %
  the internal system events are deadlock-free, i.e., there must be
  one internal system event enabled.
\end{theorem}
\begin{proof}
  This is based on the generation of our \EventB model (according to
  the basis structure as seen in Figure~\ref{fig:basis}).  In
  particular, we consider the different cases corresponding to the
  different ``states'', i.e., |READY TO DE-QUEUE|, |FIRIGIN TRIGGERED|
  , and |FIRING UNTRIGGERED|.
  \begin{itemize}
  \item When the system is in the |READY TO DE-QUEUE| state, %
    |uc = TRUE & dt = {}|.  %
    according to our assumption, we have |iQ /= {}|, hence
    |dequeueInternalTrigger| event is enabled.
    
  \item When the system is in the |FIRIGIN TRIGGERED| state,
    either one of the triggered events is enabled or the
    |noTriggeredTransitionsEnabled| event is enabled.
    
  \item Similarly, when the system is in the |FIRING UNTRIGGERED|
      state, either one of the untriggered events is enabled or the
      |noUntriggeredTransitionsEnabled| event is enabled.  
  \end{itemize}
\end{proof}
    
\begin{corollary}[System Events are Relative Deadlock-Free]
  Under the condition that %
  |eQ /= {} !or iQ /= {} !or uc = FALSE !or dt /= {}|, %
  the system events are deadlock-free, i.e., there must be
  one system event enabled.
\end{corollary}
\begin{proof}
  This is based on the generation of our \EventB model (according to
  the basis structure as seen in Figure~\ref{fig:basis}) and
  Theorem~\ref{thm:Internal-DLF}.
  \begin{itemize}
  \item In the case where |iQ /= {} !or uc = FALSE !or dt /= {}|,
    according to Theorem~\ref{thm:Internal-DLF}, one of the internal
    events is enabled.
    
  \item Otherwise, i.e., |iQ = {} & uc = TRUE & dt = {}|, according to
    our assumption, |eQ /= {}|. In this case, the
    |dequeueExternalTriggered| event is enabled.
\end{itemize}
\end{proof}

In order to reason about any liveness/responsiveness properties, we
have to make assumptions about how often an event will be invoked.
Here, we assume that all the system events are strongly fair.
\begin{assumption}[Strongly Fair System Events]
  \label{asm:SF}
  We assume that system events, i.e., |dequeueExternalTriggered|
  and \emph{internal system events} are strongly fair, i.e., if a system
  event is enabled infinitely often, eventually, it will be eventually
  invoked.
\end{assumption}

\ColinInlineComment{We have some updates to this section... can we relax SF now we have queues? MAYBE WEAK FAIRNESS IS ENOUGH}
\SonInlineComment{If the model are deterministic, WF would be enough.}

\subsection{Termination of Responses for External Triggers}
\label{sec:contr-rema-resp}

We first define the notion of event convergence.
\begin{definition}[Event Convergence]
  \label{def:conv}
  A set of events is said to be convergent if there cannot exist an
  infinite sequence of events from the set.  As a result, for every
  event in the set, there can only be a finite sequence of them.
\end{definition}

We start first by proving that it is always the case that the system
will comeback to the |READY TO DE-QUEUE| state and |iQ = {}|,
i.e., it is ready to dequeue an external trigger (if any).  This
property is guaranteed under the assumption of internal event
convergence.  This is stated as the following theorem.
\begin{theorem}[Finite Internal Events]
  \label{thm:finite-internal-events}
  Given that the internal events are convergent, the system's 
  internal queue is always eventually empty and the system transitions to the
  \emph{Ready to De-queue} state.  This is formalised as
  \begin{center}
    |GF(iQ = {} & uc = TRUE & dt = {})|~.
  \end{center}
\end{theorem}
\begin{proof}
  Assuming that the properties is not satisfied, i.e., eventually,
  it is always the case that %
  |iQ /= {} !or  uc = FALSE !or dt /=  {})|.  %
  This can be formalised as follows.
  \begin{center}
    |FG(iQ /= {} !or uc = FALSE !or dt /= {})|~.    
  \end{center}
  According to Theorem~\ref{thm:Internal-DLF}, the internal events
  will always be deadlock-free, and as a result, at least one
  of the internal event is enabled infinitely often. Under
  Assumption~\ref{asm:SF}, this internal event will eventually be
  invoked infinitely often.  Under convergence assumption for internal
  events, and according to Definition~\ref{def:conv}, there cannot be
  an infinite occurrence of internal events, which leads to
  contradiction.
\end{proof}


\begin{theorem}[Responsiveness to External Triggers]
  If an external trigger is in the queue, then eventually, it will be dequeue.
  \begin{center}
    |G(t !: content(eQ) => F([dequeueExternalTriggered.t]))|~,
  \end{center}
  where we use |[dequeueExternalTriggered.t]| to denote the occurrence of
  |dequeueExternalTriggered| with parameter |t|, i.e., |t| is processed.
\end{theorem}
\begin{proof}
  Assuming that |t !: content(eQ)|. Since |eQ /= {}| and according to
  Theorem~\ref{thm:finite-internal-events}, we have that
  |dequeueExternalTriggered| is enabled infinitely often.  Since this
  event is strongly fair (Assumption~\ref{asm:SF}), it is taken
  eventually. We have two cases.
  \begin{itemize}
  \item If |t = head(eQ)|, it means we have
    |[dequeueExternalTriggered.t]|
    
  \item If |t /= head(eQ)|, an occurrence of |dequeueExternalTriggered|
    will move |t| closer to be the head of the external queue |eQ| and
    eventually it will become the head of the queue and subsequently
    be processed eventually.
  \end{itemize}
\end{proof}

\subsubsection{Proof of Convergence}
\label{sec:proof-convergence}
The responsiveness to external triggers presented in the previous
Subsection relies on the proof of convergence for internal events. The
proof of convergence will need to be done for each individual SCXML
diagram as it does not hold priori.  We present a generic approach to
reason about the proof of convergence relying on lexicographic as
follow.

A standard technique for proving event convergence is based on
variants.  In particular, given a variant, if all events guarantee to
``decrease'' the variant and the variant is bounded below the set of
events converge.  A variant in \EventB can be a natural number
(bounded bellow by |0|) or a finite set (bounded below by the empty
set |{}|).

Moreover, for a set of events, the variants $V_1, V_2, ...$ are combined into a
lexicographic variant, i.e., $(V_1, V_2, ...)$ with $V_1$ has a higher
priority than $V_2$, etc. An vent is said to decrease this
lexicographic variant if it either decreases $V_1$ or if it keeps
$V_1$ the same and decreases $V_2$, so on and so forth.  Lexicographic
variants are supported in the latest Rodin version 3.5.

Our generic approach to construct a lexicographic variant is according
to the following order and the rule for each variant.
\begin{itemize}
\item $V_{externalTriggered}$ = |dt /\ ExternalTrigger|.  This variant
  is used to prove the convergence for any externally triggered events
  (i.e., triggered event by some external trigger). These event remove
  the external trigger from |dt| hence ``decrease'' |dt| to the empty
  set.

\item Variants based on the state machine to prove the convergence of
  internally triggered events and untriggered events.  This depends on
  the SCXML diagram and we will illustrate this on the example later.
  
\item $V_{dequeueInternalTriggered}$ = |length(iQ)|.  This variant is
  used to prove the convergence of the |dequeueInternalTriggered| event.
  Since this event remove the head of the |iQ|, it decreases the
  length of the |iQ| trivially.  While other events might increase
  |iQ|, by raising new internal triggers. However, these events should
  have been proved to converge using higher-priority variants.
  
\item $V_{noTriggeredTransitionsEnabled}$ = |dt|.  This variant is used to
  prove the convergence of the |noTriggeredTransitionsEnabled| event.
  The event discard the trigger in |dt| hence ``decrease'' |dt| to the
  empty set.
  
\item $V_{noUntriggeredTranstitionsEnabled}$ = |{uc, TRUE}|.  This variant is
  used to prove the convergence of the
  |noUntriggeredTransitionsEnabled| event.  The event changes |uc|
  flag from |FALSE| to |TRUE|, hence ``decrease'' the variant from
  |{FALSE, TRUE}| to |{TRUE}|.
\end{itemize}
Note that we do not attempt to prove the convergence of any future
events here. Instead, we assume that these future events will be prove
to be convergence later.
\SonInlineComment{We might need to discuss the effect of future events
with the later variants.}

% Order of the variants
We now discuss the specific variants for the Drone example based on
the actual state-chart as showed in Figure~\ref{fig:drone4}.  The
variants are for the internally triggered events and untriggered
events. The lexicographic order of the variant use to prove the
convergence of the events depending (1) on the \emph{nested structure}
of the transitions and (2) on the \emph{order of the transitions} with
the same nested level.  For example, the variant for proving the
convergence for the transition from |SHUTDOWN| to |OFF| will have a
higher priority than the one for the transition from |TAKEOFF| to
|FLY|, and this variant subsequently has higher priority than the one
for the transition from |CLIMB| to |HOVER|.  Furthermore, the variant
for proving the convergence for the transition from |TAKEOFF| to |FLY|
has higher priority than the one for the transition from |FLY| to
|DESCEND|.

% Shape of the variants
The translation of SCXML state-chart into UML-B/\EventB represents each
state by a Boolean variable, |TRUE| if the system in that state and
|FALSE| otherwise. As a result, the variant for proving the convergence
of an event going out of a state |S| can be |{S, FALSE}|: the
transition ``decreases'' the value of the variant from |{TRUE, FALSE}|
to |FALSE|.

Based on the above analysis, the variants that we used for proving the
convergence of the internally triggered events and untriggered events
in the Drone example are.
\begin{itemize}
\item |{SHUTDOWN, FALSE}|

\item |{TAKEOFF, FALSE}|

\item |{FLY, FALSE}|

\item |{BATTERYOK, FALSE}|

\item |{CLIMB, FALSE}|

\item |{CLIMB2, FALSE}|
\end{itemize}

This variant proof are available in the Rodin archive associated with this study.
\SonComment{To put the URL of the model}.


\subsection{Correct Responses to External Triggers}
\label{sec:corr-resp-extern}

% While \EventB refinements have also been shown to preserve some liveness properties under certain conditions~\cite{hoang2016ltl}, there are not yet efficient supporting tools for the technique.%
% % \SonComment{We probably need to move this to related work}

% Instead, we can express the property in \LTL  and use the \PROB\footnote{ProB is an animator, constraint solver and model checker for the B-Method. https://www3.hhu.de/stups/prob} model checker to verify it.
In our current approach, we express liveness properties in \LTL  and use the 
\PROB model checker to verify them.
In general, our liveness properties will have the following form:
\begin{center}
  |G([external_trigger_event] => F{predicate})|~,
\end{center}
where the predicate concerns variables |v| that the system maintains, and may refer to old values |old(v)| that existed when the external trigger occurred.
To specify a liveness property to be verified, a special \LTL element is added to the \SCXML model with attributes, property (a string of the above form)  and refinement (an integer indicating the refinement level at which the property should be verified).
The translator generates a separate `branch' refinement for each \LTL property to be verified. 
In this special refinement, history variables are added to record the value at the state when the external trigger occurs, of any variables that are referenced as `old' values.
A text file is automatically generated containing the \LTL property to be checked. 
In this generated version, an assumption of strong fairness is added for all other events in the model.
Without this assumption, the system may never achieve the expected response to a trigger. 
Therefore it corresponds to a requirement that the system can always make satisfactory progress and not become live locked.
%This assumption is stronger than necessary since some events will not affect the outcome, but is easier to generate and is sufficient for our verification aim. 
For simplicity we omit this assumption from the remaining examples.
\begin{center}
  |SF[e1] & SF[e2]... => G([external_trigger _event] => F[predicate])|
\end{center}
This property can be added into the ProB model checker LTL formula text field.

We illustrate the method with an example of a temporal property that we expect to hold in the drone \SCXML system. 
The liveness property that we wish to  verify is that, after an external trigger event |decreaseCharge|, the battery charge value should  decrease in value.
\begin{center}
  |G ([ExternalTriggerEvent_decreaseCharge] => F {charge < old(charge)})|~.
\end{center}
However, we could not verify this property.
The counter example traces that \PROB provided gave us a better understanding of the reasons why. 
The property as stated is too strong (i.e. not true) for our model; there are additional conditions that need to be considered and added as part of the antecedent.
\begin{itemize}
\item
Our model represented the trigger queues abstractly as sets which meant that the |decreaseCharge| trigger may never be dequeued.
The standalone version of \PROB allows strong fairness to be specified for particular parameter values but this does not work in the Rodin plug-in for \PROB. 
In any case, a more accurate (concrete) representation of the queue fixes the problem and improves our model.
\item 
The charge is not always decreased in response to the |decreaseCharge| trigger.
The controller only monitors battery charge while in the |BATTERYOK| state and discards the trigger in other states.
Also, the controller stops decreasing charge when it approaches 0. 
To cater for this we added a pre-condition |BATTERYOK = TRUE ∧ charge ≥10| to the \LTL property.
\item
Even if this pre-condition is true when the trigger is raised, another trigger (e.g. |off|) may already be in the queue and take the controller out of |BATTERYOK| before the |decreaseCharge| trigger is dequeued.
Again we strengthen the pre-condition |off ∉ dt ∪ eQ| of the \LTL expression to avoid this situation.
\end{itemize}
After making these changes the final form of the \LTL property, which \PROB was able to exhaustively check and confirm was as follows:
\begin{center}
	|G([ExternalTriggerEvent_decreaseCharge] & {BATTERYOK=TRUE & charge>=10 &|
		|off/:SCXML_dt\/SCXML_eq} => F {charge < old(charge)})|~.
\end{center}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
