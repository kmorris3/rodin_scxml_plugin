% !TEX root = ../main.tex


\section{Introduction}

Possible outline:
\begin{itemize}
\item Motivation
\item Background and Previous Work
\item Description of Sample Application
\item Statechart Refinements
\item Verification of Safety Properties 
\item Results
\item Conclusion 
\end{itemize}

\newcommand{\SCs}{{{Statecharts}}}
\newcommand{\SC}{{{Statechart}}}


\todo{Rob is working on the intro}  Reactive \SCs are open systems capable of receiving potentially non-deterministic input.  This work
exposes a shallow embedding of open \SCs\cite{} semantics in Event B.
\SCs provide a graphical language, generalized from state
machines, that is popular with engineers, variants of which appear in
Matlab Simulink/Stateflow\cite{} and the Ansys tools.  Particularly
attractive is providing accessibility to abstraction/refinement via
Rodin/Event-B which has an intuitive metaphor in the Statechart
semantics\cite{prev-work}.  The commercial tools have similar ideas
expressed as encapsulation and composition but not entailing any
formal guarantees.  The hope is that engineers can better understand
the origin of proof obligations in refinements and achieve formal
guarantees earlier in their designs where it is most tractable.

Previous work has developed a number of different semantics all with
different purposes and
outcomes~\cite{Syriani_2019,Harel,Maraninchi91theargos}.  Because this
work is focused on a mapping to Event-B, safety property preserving
refinement is key.  Event-B provides not only a definition of
refinement but a rubric for finding valid refinements and this is
carried over into the \SCs work presented here.  In our version of \SC
semantics, refinement means a subsetting of traces from an
abstraction.  This has the beneficial effect of preserving safety
properties from abstraction to refinement and permits proofs to be
discharged at the highest tractible level of abstraction.  It is at
the highest level of abstraction that proofs are presumabley the
easiest to discharge.

Many incompatible definitions of refinement have been posed by
others\cite{Syriani_2019,Maraninchi91theargos} and that can lead to
confusion.  Though these separate refinements have different goals,
all of which may be attractive to systems designers in different ways,
preservation of safety proofs is the goal here.  While these other
forms of refinement cannot be said to conflict with the one presented
here, they will not always preserve safety properties.  From the
Event-B vernacular it might be better to relabel these other
approaches not as methods of model ``refinement'', but rather methods
of model ``elaboration''.  \todo{Karla, Colin: have a look that this sentence, I believe this is supportable, but it might raise hackles }

Preservation of safety across refinement requires only a few
restrictions to the original\cite{Harel} \SCs (e.g. transitions cannot
cross containment boundaries arbitrarily), but still allows for both
parallel and hierarchical composition.  With these restrictions
composition becomes a refinement, but not all refinements are
compositions.  Such a unification of composition and refinement can
lead, not only to code reuse, but reuse of proofs.




%% {\color{red}
%% Ideas on content
%% We prove properties in early refinements - because easier to see - (so far fully automatic - try proving battery inv in later refinement)
%% 	although we put everything in the same model we envisage gradual construction	
%% 	we could also build a Sirius tool that can show views at each refinement.

%% We simulate the translation with the scenario checker. It automatically runs to completion (events are annotated as internal and prioritised)
%% This shows the main intended R2C behaviour for a refinement level.
%% Other behaviours are possible depending on future refinement - e.g. a completion can occur without taking enabled transitions if in future we might strengthen a guard.
%% 	these can be explored by single event stepping without the scenario checker big step.

%% proof forces us to finalise transitions..
%% 	.. i.e. to remove non-determinism that allows for some future refinement.
%% 		(in usual event-b it is not built in to the 'engine' and is only checked when the next refinement is provided..
%% 		.. we only have this finalisation because we needed to model the run to completion queueing mechanisms, hence new transitions modify old variables (queues))
%% 	we have to limit what can be done in later refinements as some things could violate what is proved.
%% 	e.g. a response transition must come next (to make the invariant before completion) so we cannot strengthen its guards any more.
%% 	e.g. similarly a trigger raised as a response must be used in the way that preserves the invariant, so future transitions may not consume it.

%% Also section on how we arrived at the new translation.
%% 	adding the invariant about only one dequeued trigger at a time - otherwise proof did not discharge about the future triggered transitions
%% 		(because consuming another dequeued trigger would discard the one we are interested in)
%% 	the drone model made us rethink the basis.. we had to dequeue triggers.. (why?)
%% }
